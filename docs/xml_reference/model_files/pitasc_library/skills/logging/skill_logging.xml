<?xml version="1.0" encoding="UTF-8"?>

<pitasc>

    <models>
        <include package="pitasc_library" file="skills/skill_cartesian.xml"/>
        <include package="pitasc_library" file="scripts/logging.xml"/>

        <type id="skill_log_cartesian" prototype="skill_cartesian">
            <meta>
                <member id="description">Logs position and/or orientation of a frame w.r.t. a reference skill into a file</member>
            </meta>

            <data>
                <type id="reference_frame" prototype="string_parameter">
                    <meta>
                        <member id="description">Defines the reference frame (origin and axes) for the logged cartesian data</member>
                        <member id="visibility">required</member>
                    </meta>
                </type>

                <type id="measured_frame" prototype="string_parameter">
                    <meta>
                        <member id="description">The frame which cartesian data is logged</member>
                        <member id="visibility">required</member>
                    </meta>
                </type>

                <type id="file_name" prototype="string_parameter">
                    <meta>
                        <member id="description">Full path and name (incl. extension) of logging file.
                            Non-existing directories are created.
                            The following artifacts (enclosed by curly brackets) are dynamically resolved:
                            '{rospkg (..)]}': full path to rospackge (..) (cf. roscd);
                            '{time (..)}': current time with respective formating (..) (cf. std::strftime)</member>
                        <member id="visibility">required</member>
                    </meta>
                </type>
                <type id="buffer_length" prototype="int_parameter">
                    <meta>
                        <member id="description">Initial length of the preallocated buffer during logging.
                            buffer_length = #samples * (#logged_coordinates + 1).
                            May be extended on the fly.</member>
                        <member id="visibility">expert</member>
                    </meta>
                    <data>512</data>
                </type>
                <type id="filter" prototype="string_csv">
                    <meta>
                        <member id="description">Explicit names of the measurements to be logged.</member>
                        <member id="visibility">basic</member>
                    </meta>
                    <data></data>
                </type>

                <!-- Implementation details below: -->

                <member id="target_frame" reference_id="reference_frame" />
                <member id="target_frame.meta.visibility">hidden</member>

                <member id="tool_frame" reference_id="measured_frame" />
                <member id="tool_frame.meta.visibility">hidden</member>

                <member id="scripts">
                    <clone prototype="script_measurement_logger">
                        <member id="provider" reference_id="collections.target_to_tool.chains"/>
                        <member id="file_name" reference_id="file_name" />
                        <member id="buffer_length" reference_id="buffer_length" />
                        <member id="filter" reference_id="filter" />
                        <member id="use_simple_filter_keys">True</member>
                    </clone>
                </member>

            </data>
        </type>

        <type id="skill_log_force" prototype="skill_force">
            <meta>
                <member id="description">Logs a force/torque in a desired frame into a file</member>
            </meta>

            <data>
                <member id="force_frame.meta.description">Frame defining the desired position and axes for measuring force and torque</member>

                <type id="file_name" prototype="string_parameter">
                    <meta>
                        <member id="description">Full path and name (incl. extension) of logging file.
                            Non-existing directories are created.
                            The following artifacts (enclosed by curly brackets) are dynamically resolved:
                            '{rospkg (..)]}': full path to rospackge (..) (cf. roscd);
                            '{time (..)}': current time with respective formating (..) (cf. std::strftime)</member>
                        <member id="visibility">required</member>
                    </meta>
                </type>
                <type id="buffer_length" prototype="int_parameter">
                    <meta>
                        <member id="description">Initial length of the preallocated buffer during logging.
                            buffer_length = #samples * (#logged_coordinates + 1).
                            May be extended on the fly.</member>
                        <member id="visibility">expert</member>
                    </meta>
                    <data>512</data>
                </type>
                <type id="filter" prototype="string_csv">
                    <meta>
                        <member id="description">Explicit names of the measurements to be logged.</member>
                        <member id="visibility">basic</member>
                    </meta>
                    <data></data>
                </type>

                <!-- Implementation details below: -->

                <member id="scripts">
                    <clone prototype="script_measurement_logger">
                        <member id="provider" reference_id="collections.force_chain.chains"/>
                        <member id="file_name" reference_id="file_name" />
                        <member id="buffer_length" reference_id="buffer_length" />
                        <member id="filter" reference_id="filter" />
                        <member id="use_simple_filter_keys">True</member>
                    </clone>
                </member>

            </data>
        </type>

    </models>

</pitasc>
